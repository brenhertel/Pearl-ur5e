import moveit_msgs.msg
import trajectory_msgs.msg
import geometry_msgs.msg
import numpy as np
import copy
import rospy
import moveit_commander
from genpy import Duration
from jerk_profile import JerkProfile


def gen_next_a(current_accel, jerk_with_sign, time_step):
	# type: (float, float, float) -> float
	"""Generates a smooth trajectory's next acceleration value with numerical integration

	Follows the equation:

	:math:`a_{k+1}=a_{k}+s_{k}j_{k}t_{k}`
	
	:param current_accel: the trajectory's current acceleration value
	:param jerk_with_sign: the trajectory's current signed jerk value
	:param time_step: the duration between the current timestamp and the next timestamp
	:type current_accel: float
	:type jerk_with_sign: float
	:type time_step: float
	:returns: the next acceleration value
	:rtype: float
	"""

	return current_accel + (jerk_with_sign * time_step)


def gen_next_v(current_accel, current_vel, jerk_with_sign, time_step):
	# type: (float, float, float, float) -> float
	"""Generates a smooth trajectory's next velocity value with numerical integration

	Follows the equation:

	:math:`v_{k+1}=v_{k}+a_{k}t_{k}+\\frac{s_{k}j_{k}}{2}t^{2}_{k}`

	:param current_accel: the trajectory's current acceleration value
	:param current_vel: the trajectory's current velocity value
	:param jerk_with_sign: the trajectory's current signed jerk value
	:param time_step: the duration between the current timestamp and the next timestamp
	:type current_accel: float
	:type current_vel: float
	:type jerk_with_sign: float
	:type time_step: float
	:returns: the next velocity value
	:rtype: float
	"""

	return current_vel + (current_accel*time_step) + ((jerk_with_sign / 2) * (time_step ** 2))


def gen_next_p(current_accel, current_vel, current_pos, jerk_with_sign, time_step):
	# type: (float, float, float, float, float) -> float
	"""Generates a smooth trajectory's next position value with numerical integration

	Follows the equation:

	:math:`p_{k+1}=p_{k}+v_{k}t_{k}+\\frac{a_{k}}{2}t^{2}_{k}+\\frac{s_{k}j_{k}}{6}t^{3}_{k}`
	
	:param current_accel: the trajectory's current acceleration value
	:param current_vel: the trajectory's current velocity value
	:param current_pos: the trajectory's current position value
	:param jerk_with_sign: the trajectory's current signed jerk value
	:param time_step: the duration between the current timestamp and the next timestamp
	:type current_accel: float
	:type current_vel: float
	:type current_pos: float
	:type jerk_with_sign: float
	:type time_step: float
	:returns: the next position value
	:rtype: float
	"""

	return current_pos + (current_vel * time_step) + ((current_accel / 2) * (time_step ** 2)) + ((jerk_with_sign / 6) * (time_step ** 3))


def generate_smooth_trajectory_with_limits(input_plan, jerk_profile_type, jerk_min=-1.0, jerk_max=None):
	# type: (moveit_msgs.msg.RobotTrajectory, function, float, float) -> moveit_msgs.msg.RobotTrajectory
	"""Produces a smoothed trajectory given hard jerk min/max limits

	**Warning**: this function should not be used to produce a usable trajectory to command a robot. It is instead intended for testing and/or generating models for one joint at a time, since all joints will have the same position goal.
	
	:param input_plan: a trajectory generated by MoveIt to smooth
	:param jerk_profile_type: any function (lambda or class function) that will translate jerk limits to an array of jerk values for seven timestamps
	:param jerk_min: the defined minimum jerk value (defaults to -1.0)
	:param jerk_max: the defined maximum jerk value (defaults to None - if none given, the maximum will be the minimum negated)
	:type input_plan: moveit_msgs.msg.RobotTrajectory
	:type jerk_profile_type: function
	:type jerk_min: float
	:type jerk_max: float or None
	:returns: a trajectory smoothed to the provided jerk profile (will not have the correct final positions)
	:rtype: moveit_msgs.msg.RobotTrajectory
	"""

	# Make sure both min and max are defined
	if jerk_max is None:
		jerk_max = -jerk_min

	# Initialize the jerk profile with the provided max/min jerk values
	jerk_profile = jerk_profile_type(jerk_min, jerk_max)

	initial_state = input_plan.joint_trajectory.points[0]  # type: trajectory_msgs.msg.JointTrajectoryPoint
	final_state = input_plan.joint_trajectory.points[-1]  # type: trajectory_msgs.msg.JointTrajectoryPoint
	
	# Create an array of timestamps to create 7 time intervals
	times = np.linspace(initial_state.time_from_start.to_sec(), final_state.time_from_start.to_sec(), 8, retstep=True)
	t = times[0]
	t_step = float(times[1])

	result = copy.deepcopy(input_plan)
	# Clears the trajectory points, leaving an identical trajectory with no points
	result.joint_trajectory.points[:] = []

	# For each point ts (index k) in all times t
	for k, ts in enumerate(t):
		current_jerk = jerk_profile[k-1]
		new_point = trajectory_msgs.msg.JointTrajectoryPoint()
		new_point.time_from_start = Duration.from_sec(ts)
		if k == 0:  # First timestamp, so use initial pos, and vel (accel=0) to start deriving
			new_point.accelerations = [0] * len(initial_state.accelerations)
			new_point.velocities = initial_state.velocities
			new_point.positions = initial_state.positions
		else:  # Generate new values based on previous ones
			new_point.accelerations = [gen_next_a(x, current_jerk, t_step) for x in result.joint_trajectory.points[-1].accelerations]
			new_point.velocities = [gen_next_v(result.joint_trajectory.points[-1].accelerations[x], result.joint_trajectory.points[-1].velocities[x], current_jerk, t_step) for x in range(len(result.joint_trajectory.joint_names))]
			new_point.positions = [gen_next_p(result.joint_trajectory.points[-1].accelerations[x], result.joint_trajectory.points[-1].velocities[x], result.joint_trajectory.points[-1].positions[x], current_jerk, t_step) for x in range(len(result.joint_trajectory.joint_names))]
		result.joint_trajectory.points.append(new_point)
	
	return result


def generate_smooth_trajectory(input_plan, jerk_profile_type):
	# type: (moveit_msgs.msg.RobotTrajectory, JerkProfile) -> moveit_msgs.msg.RobotTrajectory
	"""Produces a smoothed trajectory given a defined jerk profile
	
	:param input_plan: a trajectory generated by MoveIt to smooth
	:param jerk_profile_type: a jerk profile class (not an instance)
	:type input_plan: moveit_msgs.msg.RobotTrajectory
	:type jerk_profile_type: JerkProfile
	:returns: a trajectory smoothed to the provided jerk profile with the provided position endpoints
	:rtype: moveit_msgs.msg.RobotTrajectory
	"""
	
	# Return an empty trajectory if there is no data that can be used
	if len(input_plan.joint_trajectory.joint_names) == 0:
		return moveit_msgs.msg.RobotTrajectory()

	initial_state = input_plan.joint_trajectory.points[0]  # type: trajectory_msgs.msg.JointTrajectoryPoint
	final_state = input_plan.joint_trajectory.points[-1]  # type: trajectory_msgs.msg.JointTrajectoryPoint
	
	# Create an array of timestamps to create 7 time intervals
	# t holds the 8 timestamps, while t_step is the step between each interval
	times = np.linspace(initial_state.time_from_start.to_sec(), final_state.time_from_start.to_sec(), 8, retstep=True)
	t = times[0]
	print('t')
	print(t)
	t_step = float(times[1])

	# Copy the original trajectory to retain header data
	result = copy.deepcopy(input_plan)
	# Clears the trajectory points, leaving an identical trajectory with no points
	result.joint_trajectory.points[:] = []

	# Create new empty points for the new generated timestamps
	for i in range(len(t)):
		result.joint_trajectory.points.append(trajectory_msgs.msg.JointTrajectoryPoint(time_from_start=Duration.from_sec(t[i])))

	for joint_index in range(len(input_plan.joint_trajectory.joint_names)):
		# Generate the jerk limits based on the DoF's final position and the trajectory's total time
		max_jerk = find_jerk_limit(final_state.positions[joint_index] - initial_state.positions[joint_index], final_state.time_from_start.to_sec(), jerk_profile_type)
		min_jerk = -max_jerk

		# Initialize the jerk profile with the generated max/min jerk values
		jerk_profile = jerk_profile_type(min_jerk, max_jerk)  # type: JerkProfile

		for k in range(len(t)):
			current_jerk = jerk_profile.steps[k-1]
			if k == 0:
				# Use initial position data as the first point to integrate from
				# Initialize acceleration with 0 (to avoid non-zeroed acceleration curves)
				result.joint_trajectory.points[k].accelerations.append(0)
				result.joint_trajectory.points[k].velocities.append(initial_state.velocities[joint_index])
				result.joint_trajectory.points[k].positions.append(initial_state.positions[joint_index])
			else:
				# Use integration to calculate the rest of the profile
				result.joint_trajectory.points[k].accelerations.append(gen_next_a(result.joint_trajectory.points[k-1].accelerations[joint_index], current_jerk, t_step))
				result.joint_trajectory.points[k].velocities.append(gen_next_v(result.joint_trajectory.points[k-1].accelerations[joint_index], result.joint_trajectory.points[k-1].velocities[joint_index], current_jerk, t_step))
				result.joint_trajectory.points[k].positions.append(gen_next_p(result.joint_trajectory.points[k-1].accelerations[joint_index], result.joint_trajectory.points[k-1].velocities[joint_index], result.joint_trajectory.points[k-1].positions[joint_index], current_jerk, t_step))
	
	return result


def find_jerk_limit(position_delta, total_duration, jerk_profile_type):
	# type: (float, float, JerkProfile) -> float
	"""Converts a trajectory's position delta, duration, and a jerk profile into a jerk maximum (with the assumption the minimum is -max)

	:param position_delta: the change in position between the beginning and end of a joint's trajectory
	:param total_duration: the length of the trajectory
	:param jerk_profile_type: a jerk profile class (not an instance)
	:type position_delta: float
	:type total_duration: float
	:type jerk_profile_type: JerkProfile
	:returns: the maximum jerk value
	:rtype: float
	"""

	jerk_slope = jerk_profile_type.time_to_jerk_slope(total_duration)
	# When finding jerk limits, treat UDDU the same as DUUD and UDUD the same as DUDU by flipping the equation
	# DUUD and DUDU may not be used, keeping just in case
	# if jerk_profile_type in (DUUD, DUDU):
	# 	coeff = -1
	# else:
	# 	coeff = 1
	# return coeff * (position_delta / jerk_slope)
	return position_delta / jerk_slope


def publish_trajectory(publisher, trajectory, robot):
	# type: (rospy.Publisher, moveit_msgs.msg.RobotTrajectory, moveit_commander.RobotCommander) -> None
	"""Sends a generated trajectory to a ROS publisher as a DisplayTrajectory msg
	
	Uses a RobotCommander instance to get the robot's current position

	:param publisher: the rospy Publisher to advertise on
	:param trajectory: the RobotTrajectory to display
	:param robot: the RobotCommander of the robot to display with
	:type publisher: rospy.Publisher
	:type trajectory: moveit_msgs.msg.RobotTrajectory
	:type robot: moveit_commander.RobotCommander
	:returns: None
	:rtype: None
	"""
	display_trajectory = moveit_msgs.msg.DisplayTrajectory()
	display_trajectory.trajectory_start = robot.get_current_state()
	display_trajectory.trajectory.append(trajectory)
	publisher.publish(display_trajectory)


def wait_for_state_update(box_name, scene, box_is_known=False, box_is_attached=False, timeout=4):
	# type: (str, moveit_commander.PlanningSceneInterface, bool, bool, float) -> bool
	"""Waits for the state of the planning scene to be updated to what is expected

	:param box_name: the name of a planning scene box object that should be added to the scene
	:param scene: the planning scene to check
	:param box_is_known: whether box_name should be known within the planning scene
	:param box_is_attached: whether box_name should be attached within the planning scene
	:param timeout: the amount of time to wait for an update before giving up
	:type box_name: str
	:type scene: moveit_commander.PlanningSceneInterface
	:type box_is_known: bool
	:type box_is_attached: bool
	:type timeout: float
	:returns: False if a timeout occurs, True if the object is found within the planning scene
	:rtype: bool
	"""
	start = rospy.get_time()
	seconds = rospy.get_time()
	while (seconds - start < timeout) and not rospy.is_shutdown():
		attached_objects = scene.get_attached_objects([box_name])  # type: dict[str, moveit_msgs.msg.AttachedCollisionObject]
		is_attached = len(attached_objects.keys()) > 0
		known_objects = scene.get_known_object_names()  # type: list[str]
		is_known = box_name in known_objects
		if (box_is_attached == is_attached) and (box_is_known == is_known):
			return True
		rospy.sleep(0.1)
		seconds = rospy.get_time()
	return False


def add_table(robot, scene, timeout=4):
	# type: (moveit_commander.RobotCommander, moveit_commander.PlanningSceneInterface, float) -> bool
	"""Adds a box object to a planning scene that represents a table the robot sits on

	:param robot: the RobotCommander object representing the robot
	:param scene: the planning scene to add the table to
	:param timeout: the amount of time to wait for a planning scene state update before giving up (passed on to `wait_for_state_update`)
	:type robot: moveit_commander.RobotCommander
	:type scene: moveit_commander.PlanningSceneInterface
	:type timeout: float
	:returns: True if the table was successfully added to the planning scene, False otherwise
	:rtype: bool
	"""
	box_pose = geometry_msgs.msg.PoseStamped()
	robot_planning_frame = robot.get_planning_frame()  # type: str
	box_pose.header.frame_id = robot_planning_frame
	box_pose.pose.orientation.w = 1.0
	box_pose.pose.position.z = -0.07
	table_name = "table"
	scene.add_box(table_name, box_pose, size=(10, 10, 0.1))
	return wait_for_state_update(table_name, scene, box_is_known=True, timeout=timeout)


def add_wall(robot, scene, timeout=4):
	# type: (moveit_commander.RobotCommander, moveit_commander.PlanningSceneInterface, float) -> bool
	"""Adds a box object to a planning scene that represents a wall the robot sits in front of

	:param robot: the RobotCommander object representing the robot
	:param scene: the planning scene to add the table to
	:param timeout: the amount of time to wait for a planning scene state update before giving up (passed on to `wait_for_state_update`)
	:type robot: moveit_commander.RobotCommander
	:type scene: moveit_commander.PlanningSceneInterface
	:type timeout: float
	:returns: True if the wall was successfully added to the planning scene, False otherwise
	:rtype: bool
	"""
	box_pose = geometry_msgs.msg.PoseStamped()
	robot_planning_frame = robot.get_planning_frame()  # type: str
	box_pose.header.frame_id = robot_planning_frame
	box_pose.pose.orientation.w = 1.0
	box_pose.pose.position.y = -0.15
	wall_name = "wall"
	scene.add_box(wall_name, box_pose, size=(10, 0.02, 10))
	return wait_for_state_update(wall_name, scene, box_is_known=True, timeout=timeout)


def shift_times(times, iterations=1):
	# type: (np.ndarray, int) -> np.ndarray
	"""Shifts an array of times so that they can be used in a plot to accurately display derivative graphs

	:param times: the array of times to shift, with length n
	:param iterations: the number of iterations to perform (useful for multiple derivatives)
	:type times: np.ndarray
	:type iterations: int
	:returns: the shifted array of times, with length n-1
	:rtype: np.ndarray
	"""
	t = times.copy()
	for i in range(iterations):
		shifted = np.array([])
		d1 = np.diff(t)
		for index, time in enumerate(d1):
			# Use midpoints between each point
			shifted = np.append(shifted, t[index] + (time / 2))
		t = shifted
	return t


def integrate_time(data, times, initial_value):
	# type: (np.ndarray, np.ndarray, float) -> np.ndarray
	"""Performs numerical integration on a dataset with relation to time and an initial value

	:param data: the data to numerically integrate
	:param times: the time data to integrate with respect to
	:param initial_value: the first value the integral should have
	:type data: np.ndarray
	:type times: np.ndarray
	:type initial_value: float
	:returns: the numeric integral of the dataset
	:rtype: np.ndarray
	"""
	result = np.array([initial_value])
	for index, point in enumerate(data):
		result = np.append(result, result[-1] + (point * times[index]))
	return result


def integrate(data, initial_value):
	# type: (np.ndarray, float) -> np.ndarray
	"""Performs numerical integration on a dataset with an initial value
	
	:param data: the data to numerically integrate
	:param initial_value: the first value the integral should have
	:type data: np.ndarray
	:type initial_value: float
	:returns: the numeric integral of the dataset
	:rtype: np.ndarray
	"""
	result = np.array([initial_value])
	for point in data:
		result = np.append(result, result[-1] + point)
	return result

